<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
  <style>
    body {
      background-color: #f8f9fa;
      font-family: "Arial", sans-serif;
    }

    h1 {
      color: #007bff;
      margin-bottom: 30px;
    }

    h2 {
      color: #343a40;
      margin-top: 30px;
      border-bottom: 2px solid #007bff;
      padding-bottom: 10px;
    }

    p {
      line-height: 1.6;
    }

    ol {
      margin-left: 20px;
    }

    .list-group-item {
      transition: background-color 0.3s;
    }

    .list-group-item:hover {
      background-color: #e9ecef;
      cursor: pointer;
    }

    footer {
      margin-top: 40px;
      padding: 20px 0;
      background-color: #007bff;
      color: #ffffff;
    }

    .caption {
      font-size: 0.85rem;
      color: #6c757d;
    }

    pre {
      background-color: #f5f5f5;
      /* Light grey background */
      border-left: 3px solid #007bff;
      /* Blue left border */
      padding: 15px;
      /* Padding around the text */
      border-radius: 5px;
      /* Rounded corners */
      overflow: auto;
      /* Allows scrolling */
      white-space: pre-wrap;
      /* Wraps long lines */
      font-family: "Courier New", Courier, monospace;
      /* Monospace font */
    }

    #intro {
      padding: 20px;
      background-color: #f9f9f9;
      /* Light background for contrast */
      border-radius: 8px;
      /* Rounded corners */
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      /* Subtle shadow */
    }

    #intro h2 {
      font-size: 24px;
      color: #333;
      /* Darker color for the heading */
      margin-bottom: 10px;
      /* Space below the heading */
    }

    #intro p {
      font-size: 16px;
      color: #555;
      /* Slightly lighter color for the text */
      line-height: 1.5;
      /* Improved line spacing */
    }

    img {
      max-width: 100%;
      /* Ensures the image will not exceed the width of its parent container */
      height: auto;
      /* Maintains the aspect ratio of the image */
    }

    #intro img {
      max-width: 100%;
      /* Responsive image */
      height: auto;
      /* Maintain aspect ratio */
      border-radius: 4px;
      /* Rounded corners for the image */
      margin-top: 10px;
      /* Space above the image */
    }

    .container {
      max-width: 93vw;
    }
  </style>
  <title>Android Pentesting Challenges</title>
</head>

<body>
  <div class="container my-5">
    <h1 class="text-center">Android pentesting challenges on Allsafe</h1>
    <ul class="list-group mb-5">
      <li class="list-group-item">
        <a href="#insecure-logging" class="text-decoration-none">1. Insecure Logging</a>
      </li>
      <li class="list-group-item">
        <a href="#hardcoded-credentials" class="text-decoration-none">2. Hardcoded Credentials</a>
      </li>
      <li class="list-group-item">
        <a href="#firebase-database" class="text-decoration-none">3. Firebase Database Misconfigurations</a>
      </li>
      <li class="list-group-item">
        <a href="#insecure-shared-preferences" class="text-decoration-none">4. Insecure Shared Preferences</a>
      </li>
      <li class="list-group-item">
        <a href="#sql-injection" class="text-decoration-none">5. SQL Injection</a>
      </li>
      <li class="list-group-item">
        <a href="#pin-bypass" class="text-decoration-none">6. PIN Bypass</a>
      </li>
      <li class="list-group-item">
        <a href="#root-detection-bypass" class="text-decoration-none">7. Root Detection Bypass</a>
      </li>
      <li class="list-group-item">
        <a href="#secure-flag-bypass" class="text-decoration-none">8. Secure Flag Bypass</a>
      </li>
      <li class="list-group-item">
        <a href="#deep-link-exploitation" class="text-decoration-none">9. Deep Link Exploitation</a>
      </li>
      <li class="list-group-item">
        <a href="#insecure-broadcast-receiver" class="text-decoration-none">10. Insecure Broadcast Receiver</a>
      </li>
      <li class="list-group-item">
        <a href="#vulnerable-webview" class="text-decoration-none">11. Vulnerable WebView</a>
      </li>
      <li class="list-group-item">
        <a href="#certificate-pinning" class="text-decoration-none">12. Certificate Pinning Bypass</a>
      </li>
      <li class="list-group-item">
        <a href="#weak-cryptography" class="text-decoration-none">13. Weak Cryptography</a>
      </li>
      <li class="list-group-item">
        <a href="#insecure-service" class="text-decoration-none">14. Insecure Service</a>
      </li>
      <li class="list-group-item">
        <a href="#object-serialization" class="text-decoration-none">15. Object Serialization Vulnerabilities</a>
      </li>
      <li class="list-group-item">
        <a href="#insecure-providers" class="text-decoration-none">16. Insecure Providers</a>
      </li>
      <li class="list-group-item">
        <a href="#arbitrary-code-execution" class="text-decoration-none">17. Arbitrary Code Execution</a>
      </li>
      <li class="list-group-item">
        <a href="#native-library-vulnerabilities" class="text-decoration-none">18. Native Library Vulnerabilities</a>
      </li>
      <li class="list-group-item">
        <a href="#smali-patch-exploitation" class="text-decoration-none">19. Smali Patch Exploitation</a>
      </li>
    </ul>

    <section id="intro">
      <h2>Introduction</h2>
      <p>
        Firstly, analyze this app with MobSF to conduct an efficient static
        analysis and understand the application flow.
      </p>

      <img src="./images/mob.png" alt="Mobile Security Framework" />
    </section>

    <section id="insecure-logging" class="mb-5">
      <h2>Insecure Logging Challenge</h2>
      <p>
        Developers often utilize logging to track their code execution and
        troubleshoot errors. However, there are instances when sensitive
        information, such as login credentials or authentication tokens, may
        inadvertently be recorded in the logs.
      </p>
    </section>

    <section class="mb-5">
      <h2>Testing Process</h2>
      <ol>
        <li>
          <strong>Connect to the Device:</strong> Ensure your device is
          connected via ADB (Android Debug Bridge).
        </li>
        <li>
          <strong>Monitor Logs:</strong> Use the <code>logcat</code> command
          to observe the device logs for any sensitive data being logged.
          <pre><code>adb logcat</code></pre>
        </li>
      </ol>
    </section>

    <section class="mb-5">
      <h2>Identifying Sensitive Data</h2>
      <p>
        Look for entries in the logs that may contain sensitive information,
        such as:
      </p>
      <ul>
        <li>Login credentials</li>
        <li>Authentication tokens</li>
        <li>Personal user data</li>
      </ul>
    </section>

    <section class="mb-5">
      <h2>Using Logcat Effectively</h2>
      <p>
        This is the command that can efficiently utilize
        <code>logcat</code> and the process:
      </p>
      <code>adb shell logcat --pid=$(adb shell pidof -s
          infosecadventures.allsafe)</code>
      <div class="text-center mb-4">
        <img src="./images/allsafecode.png" alt="Allsafe Code Output" class="img-fluid mb-2" />
        <p class="caption">Output of the command for Allsafe challenge.</p>
      </div>

      <div class="text-center mb-4">
        <img src="./images/allsafe.png" alt="Allsafe Application" class="img-fluid mb-2" />
        <p class="caption">
          Visual representation of the Allsafe application.
        </p>
      </div>

      <p>Hereâ€™s another example from the Diva challenges:</p>
      <code>adb logcat --pid=$(adb shell pidof -s jakhar.aseem.diva)</code>
      <div class="text-center mb-4">
        <img src="./images/logcatdiva.png" alt="Diva Logcat Output" class="img-fluid mb-2" />
        <p class="caption">
          Output of the logcat command for Diva challenge.
        </p>
      </div>
    </section>

    <section class="mb-5">
      <h2>Conclusion</h2>
      <p>
        Insecure logging can pose a significant security risk. Developers
        should be cautious about what data is logged and ensure that sensitive
        information is adequately protected or omitted from logs.
      </p>
    </section>
    <section id="hardcoded-credentials" class="mb-5">
      <h2>Hardcoded Credentials Challenge</h2>
      <p>
        In this challenge, you will discover credentials located in different
        parts of the application.
      </p>

      <h3>First Credential Location</h3>
      <p>The first credential can be found in the following location:</p>
      <div class="text-center mb-4">
        <img src="./images/hardcrad1.png" alt="Hardcoded Credential 1" class="img-fluid mb-2" />
        <p class="caption">Location of the first hardcoded credential.</p>
      </div>

      <h3>Second Credential Location</h3>
      <p>The second credential requires more in-depth tracing of the code.</p>
      <div class="text-center mb-4">
        <img src="./images/hardcrad2.png" alt="Hardcoded Credential 2" class="img-fluid mb-2" />
        <p class="caption">Location of the second hardcoded credential.</p>
      </div>

      <h3>Finding the <code>dev_env</code> String</h3>
      <p>
        To find the <code>dev_env</code> string, navigate to
        <code>/Resources/resources.arsc/res/values/strings.xml</code> and
        search for it.
      </p>
      <div class="text-center mb-4">
        <img src="./images/hardcra3.png" alt="Finding dev_env String" class="img-fluid mb-2" />
        <p class="caption">
          Searching for the dev_env string in strings.xml.
        </p>
      </div>
    </section>
    <section id="firebase-database" class="mb-5">
      <h2>Firebase Database Analysis</h2>
      <p>
        Firebase is a cloud-based, real-time NoSQL database that can be
        integrated into both Android and iOS applications. To begin testing,
        the first step is to identify the Firebase URL. In Jadx, navigate to
        the path
        <code>/Resources/resources.arsc/res/values/strings.xml</code> and
        search for the Firebase entry to locate the URL.
      </p>
      <div class="text-center mb-4">
        <img src="./images/firebase-database.png" alt="Firebase Database Overview" class="img-fluid mb-2" />
        <p class="caption">Overview of Firebase Database integration.</p>
      </div>

      <p>
        Next, open your browser and attempt to access the
        <code>/.json</code> endpoint. If you receive a "Permission Denied"
        response, this indicates that the database is securely configured.
        Conversely, if you receive JSON data or a <code>null</code> response,
        it implies that you have at least read permissions.
      </p>
      <div class="text-center mb-4">
        <img src="./images/flagfirebse.png" alt="Firebase JSON Access" class="img-fluid mb-2" />
        <p class="caption">
          Attempting to access the Firebase JSON endpoint.
        </p>
      </div>
    </section>

    <section id="insecure-shared-preferences" class="mb-5">
      <h2>SharedPreferences Vulnerability</h2>
      <p>
        Data stored in a <code>SharedPreferences</code> object is saved as an
        XML file within the app's data directory. In this challenge, the code
        shows that <code>getSharedPreferences("user", 0)</code> creates a
        <code>SharedPreferences</code> object named
        <code>user.xml</code> using the default mode set to
        <code>MODE_PRIVATE</code>. This file contains the plaintext username
        and password of the registered user.
      </p>
      <div class="text-center mb-4">
        <img src="./images/shredpref.png" alt="SharedPreferences Storage" class="img-fluid mb-2" />
        <p class="caption">Storage of sensitive data in SharedPreferences.</p>
      </div>

      <p>
        This approach represents a poor security practice. While non-rooted
        devices typically prevent other applications from accessing that XML
        file, the same does not hold true for rooted Android devices. You can
        verify the existence of an Insecure Data Storage vulnerability by
        navigating to
        <code>/data/data/infosecadventures.allsafe/shared_prefs/</code> and
        opening the <code>user.xml</code> file.
      </p>
      <div class="text-center mb-4">
        <img src="./images/saredprefflag.png" alt="Insecure Data Storage" class="img-fluid mb-2" />
        <p class="caption">Verifying Insecure Data Storage vulnerability.</p>
      </div>
    </section>
    <section id="sql-injection" class="mb-5">
      <h2>SQL Injection Vulnerability</h2>
      <p>
        Upon further investigation, you will notice that both the username and
        password are incorporated into a raw SQL query that lacks adequate
        sanitization.
      </p>
      <div class="text-center mb-4">
        <img src="./images/sql.png" alt="SQL Query Structure" class="img-fluid mb-2" />
        <p class="caption">Illustration of SQL Query Structure.</p>
      </div>
      <p>
        This challenge represents a basic SQL Injection scenario. The goal is
        to exploit a SQL Injection vulnerability in the login function, which
        can be accomplished using the classic payload
        <code> OR 1=1 --</code> along with a dummy password.
      </p>
      <div class="text-center mb-4">
        <img src="./images/sqlflag.png" alt="SQL Injection Flag" class="img-fluid mb-2" />
        <p class="caption">Flag for successful SQL Injection exploitation.</p>
      </div>
    </section>
    <section id="pin-bypass" class="mb-5">
      <h2>PIN Bypass Challenge</h2>
      <p>
        In this challenge, there is a hardcoded <code>Base64</code> encoded
        PIN embedded in the app that needs to be entered in the text view to
        complete the challenge. The goal is to utilize Frida to override the
        <code>checkPin</code> function, forcing it to return true for any PIN.
        However, since the PIN is a simple 4-digit number, we can also write a
        Frida script to brute-force the correct PIN. By examining the source
        code, you'll notice that the function responsible for validating the
        PIN is called <code>checkPin</code>, which returns true if the entered
        PIN matches the hardcoded value.
      </p>
      <div class="text-center mb-4">
        <img src="./images/checkpin.png" alt="Check PIN Function" class="img-fluid mb-2" />
        <p class="caption">Illustration of the checkPin function.</p>
      </div>
      <p>
        The approach here involves creating a straightforward for loop that
        invokes the <code>checkPin</code> method with every possible PIN value
        (from 0000 to 9999) as a string parameter. When the correct PIN is
        passed to the function, it will return true, signaling that the
        correct value has been found.
      </p>
      <pre>
            <code>
    Java.perform(function() {
        var pinBypassClass = Java.use("infosecadventures.allsafe.challenges.PinBypass");
        pinBypassClass.checkPin.implementation = function(inputPin) {
            for (var pinAttempt = 0; pinAttempt <= 9999; pinAttempt++) {
                var isPinValid = this.checkPin(String(pinAttempt).padStart(4, '0'));
                if (isPinValid) {
                    console.log("[+] Valid PIN found: " + pinAttempt);
                    break;
                }
            }
            return true;
        }
    });
            </code>
        </pre>
      <p>
        Next, spawn the app using Frida and inject the script with the
        following command:
      </p>
      <pre> <code>frida -U -l pin_hook.js -f infosecadventures.allsafe</code></pre>
      <div class="text-center mb-4">
        <img src="./images/pinflag.png" alt="PIN Bypass Flag" class="img-fluid mb-2" />
        <p class="caption">Flag for successful PIN bypass.</p>
      </div>
    </section>
    <section id="root-detection-bypass" class="mb-5">
      <h2>Root Detection Bypass</h2>
      <p>
        Allsafe employs RootBeer to identify whether the app is running on a
        rooted device. Although it performs several checks, all of them are
        boolean functions that can be easily hooked to return false. The
        implementation of these checks is quite straightforward, as they are
        all called from a function named <code>isRooted</code>. Thus, we can
        hook <code>isRooted</code> to force it to always return false using
        the Frida script provided below:
      </p>
      <div class="text-center mb-4">
        <img src="./images/root.png" alt="Root Detection Check" class="img-fluid mb-2" />
        <p class="caption">Illustration of RootBeer checks.</p>
      </div>
      <pre>
            <code>
    Java.perform(function() {
        var RootBeer = Java.use("com.scottyab.rootbeer.RootBeer");
    
        // Override the isRooted() method to always return false
        RootBeer.isRooted.implementation = function() {
            console.log("isRooted() called. Returning false.");
            return false;
        };
    });          
            </code>
        </pre>
      <p>
        Finally, use Frida to inject the script into the app, and you will
        easily bypass the root detection checks.
      </p>
      <div class="text-center mb-4">
        <img src="./images/rootpas.png" alt="Bypass Root Detection" class="img-fluid mb-2" />
        <p class="caption">Successfully bypassed root detection.</p>
      </div>
    </section>
    <section id="secure-flag-bypass" class="mb-5">
      <h2>Secure Flag Bypass</h2>
      <p>
        This pertains to the <code>Window flag</code> that designates the
        content of a window as secure, thereby preventing it from being
        captured in screenshots or viewed on non-secure displays. It is
        commonly utilized in banking applications. While
        <code>FLAG_SECURE</code> is not technically a vulnerability and I
        wonâ€™t delve into its intricacies, you can utilize the following Frida
        script to bypass it.
      </p>
      <div class="text-center mb-4">
        <img src="./images/secflag.png" alt="Secure Flag Bypass" class="img-fluid mb-2" />
        <p class="caption">Illustration of Secure Flag Bypass.</p>
      </div>
      <p>
        You can find the script used for this purpose at the following link:
        <a href="https://gist.github.com/su-vikas/36410f67c9e0127961ae344010c4c0ef" target="_blank">
          Frida Script
        </a>
      </p>
      <p>
        Another way to bypass this restriction is by using the
        <code>Medusa</code> tool. You can employ the module
        <code>helpers/enable_screencap</code> for this purpose.
      </p>
      <div class="text-center mb-4">
        <img src="./images/medsecflag.png" alt="Medusa Tool for Secure Flag Bypass" class="img-fluid mb-2" />
        <p class="caption">Medusa Tool for Secure Flag Bypass.</p>
      </div>
    </section>
    <section id="deep-link-exploitation" class="mb-5">
      <h2>Deep Link Exploitation</h2>
      <p>
        <b>Deep links</b> are essentially hyperlinks that enable users to directly access specific views within an
        Android application.
        Before we begin exploiting deep links, itâ€™s crucial to understand how the application handles the deep link
        data.
        I will start by examining the <code>AndroidManifest.xml</code> file, looking for <code>android:scheme</code>
        attributes within
        <data> tags. This will help us identify the deep link defined with the following attributes:
      </p>
      <ul>
        <li><code>Scheme: allsafe</code></li>
        <li><code>Host: infosecadventures</code></li>
        <li><code>Path Prefix: /congrats</code></li>
      </ul>
      <div class="text-center mb-4">
        <img src="./images/deeplink1.png" alt="Deep Link Attributes" class="img-fluid mb-2" />
        <p class="caption">Illustration of Deep Link Attributes.</p>
      </div>
      <p>
        You will also observe that the code responsible for managing the deep link is located in
        <code>infosecadventures.allsafe.challenges.DeepLinkTask</code>.
      </p>
      <div class="text-center mb-4">
        <img src="./images/deeplinks2.png" alt="Deep Link Handling Code" class="img-fluid mb-2" />
        <p class="caption">Code handling Deep Links.</p>
      </div>
      <p>
        In this scenario, the code begins by retrieving the data associated with the intent. It then checks for a
        parameter called <code>key</code> and compares its value to an entry in <code>strings.xml</code> that shares the
        same name.
        Our goal is to make sure this condition evaluates to true. To do this, we first need to extract the key, which
        is readily
        accessible in <code>strings.xml</code>.
      </p>
      <div class="text-center mb-4">
        <img src="./images/key.png" alt="Key in strings.xml" class="img-fluid mb-2" />
        <p class="caption">Key found in strings.xml.</p>
      </div>
      <p><b>Finally</b>, utilize ADB to send an intent with the correct action and data, which will activate the code
        within
        <code>DeepLinkTask</code>.
      </p>
      <pre>
          <code>
              adb shell am start -a "android.intent.action.VIEW" -d "allsafe://infosecadventures/congrats?key=ebfb7ff0-b2f6-41c8-bef3-4fba17be410c"
          </code>
      </pre>
      <div class="text-center mb-4">
        <img src="./images/deexploitation.png" alt="Deep Link Exploitation" class="img-fluid mb-2" />
        <p class="caption">Deep Link Exploitation in Action.</p>
      </div>
    </section>
    <section id="insecure-broadcast-receiver" class="mb-5">
      <h2>Insecure Broadcast Receiver</h2>
      <p>
        A <code>BroadcastReceiver</code> in Android is a component that listens for system-wide broadcast events or
        intents. For example, when your phoneâ€™s battery is low, a broadcast is sent indicating the low battery status.
        Certain apps can be set up to listen for this broadcast and adjust their behavior, such as reducing power usage
        or dimming the screen.
      </p>
      <p>
        The challenge highlights a <b>Permission Re-delegation</b> vulnerability, which allows attackers to intercept
        notes sent through Allsafe's broadcast receiver. Permission re-delegation occurs when an app with the required
        permissions performs a privileged task for another app that lacks those permissions.
      </p>
      <p>
        To investigate the broadcast receiver in the app, I'll begin by examining the <code>AndroidManifest.xml</code>
        file, looking for <code>&lt;receiver&gt;</code> tags.
      </p>
      <div class="text-center mb-4">
        <img src="./images/broadcode.png" alt="Broadcast Receiver Code" class="img-fluid mb-2" />
        <p class="caption">Broadcast Receiver in AndroidManifest.xml.</p>
      </div>
      <p>
        You'll notice two key things:
      </p>
      <ul>
        <li>An intent-filter is defined with the action <code>infosecadventures.allsafe.action.PROCESS_NOTE</code>.</li>
        <li>The code responsible for processing the broadcast is located in
          <code>infosecadventures.allsafe.challenges.NoteReceiver</code>.
        </li>
      </ul>
      <p>
        When analyzing a broadcast receiver, it's important to start by examining the <code>onReceive</code> function,
        as this is where the broadcasts are handled and processed.
      </p>
      <div class="text-center mb-4">
        <img src="./images/broad3.png" alt="Broadcast Receiver Handling Code" class="img-fluid mb-2" />
        <p class="caption">Code responsible for processing the broadcast.</p>
      </div>
      <p>
        From the code, youâ€™ll notice that it looks for three string extras: <code>server</code>, <code>note</code>, and
        <code>notification_message</code>. The first two are used to construct a URL via the <code>HttpUrl</code>
        object, while the <code>notification_message</code> is used as the content for a push notification after the
        note is sent.
      </p>
      <p>
        Since the <code>NoteReceiver</code> is exported, we can call it directly using ADB, allowing us to manipulate
        the values for <code>server</code>, <code>note</code>, and <code>notification_message</code>. This means we can
        control what appears in the push notification and where the notes are sent.
      </p>
      <p>
        To invoke the receiver, we'll use the following ADB command:
      </p>
      <pre>
        <code>
          adb shell am broadcast -a "infosecadventures.allsafe.action.PROCESS_NOTE" --es server '192.168.1.10' --es note 'Hello,World' --es notification_message 'You are Compromised' -n infosecadventures.allsafe/.challenges.NoteReceiver
        </code>
      </pre>
      <div class="text-center mb-4">
        <img src="./images/broad.png" alt="Broadcast Exploitation" class="img-fluid mb-2" />
        <p class="caption">Broadcast Exploitation in Action.</p>
      </div>
    </section>
    <section id="vulnerable-webview" class="mb-5">
      <h2>Exploiting Vulnerable WebView</h2>
      <p>
        The challenge first requires displaying an alert dialog and accessing the <code>/etc/hosts</code> file from the
        filesystem. The second part indicates that the file scheme is supported in the WebView, making it possible to
        directly access local files.
      </p>
      <p>
        Upon testing, I found that using the URL <code>file:///etc/hosts</code> successfully granted access to the hosts
        file, allowing me to view its contents.
      </p>
      <img src="./images/webvies.png" alt="Accessing /etc/hosts">
      <p>
        The first task was straightforward. I experimented with a few payloads until I discovered that using
        <code>&lt;svg onload=alert(1234567890)&gt;</code> successfully triggered an alert when the SVG was loaded.
      </p>
      <img src="./images/web2.png" alt="Triggering Alert with SVG">
    </section>

    <section id="certificate-pinning" class="mb-5">
      <h2>SSL Pinning Bypass Challenge</h2>
      <p>
        This is a basic SSL Pinning Bypass challenge. From the code, it's clear that the application sends an HTTP
        request to <code>https://httpbin.org/json</code> and uses <code>OkHttpClient.Builder</code> to enforce SSL
        pinning via the <code>TrustManager</code> method.
      </p>
      <p>
        Additionally, the app uses a <code>NetworkSecurityConfig.xml</code> file, which can be modified to trust
        user-installed certificates. This allows bypassing the SSL pinning mechanism by enabling the app to trust custom
        certificates.
      </p>
      <img src="./images/ssl.png" alt="SSL Pinning Bypass">
      <p>
        Without delving into too much detail, you can use the <a
          href="https://codeshare.frida.re/@pcipolloni/universal-android-ssl-pinning-bypass-with-frida/"
          target="_blank">Frida script for universal SSL pinning bypass</a> to intercept HTTPS traffic in Burp Suite.
      </p>
      <pre>
        <code>
          frida -U --codeshare pcipolloni/universal-android-ssl-pinning-bypass-with-frida -f infosecadventures.allsafe
        </code>
      </pre>
      <p>
        Alternatively, you can use these modules for bypass:
      </p>
      <ul>
        <li><code>http_communications/ssl-pinning-bypass</code></li>
        <li><code>http_communications/universal_SSL_pinning_bypass</code></li>
      </ul>
      <img src="./images/burp.png" alt="SSL Bypass in Burp Suite">
    </section>


    <section id="weak-cryptography" class="mb-5">
      <h2>Weak Cryptography Exploitation</h2>
      <p>
        Itâ€™s certainly a great practice to manually explore these operations, but to keep this blog concise, Iâ€™ll use
        <code>Medusa's Crypto Operations Monitoring</code> module instead. This will allow us to track encryption
        activities
        efficiently. I'll start the app with Medusa, enter any text, press ENCRYPT, and observe how Medusa logs all the
        details of the encryption process. It will provide valuable insights, including the algorithm used, the secret
        key, and the plaintext involved in the operation. You can also utilize the following module:
        <code>encryption/cipher_2</code>.
      </p>
      <img src="./images/weakcrypto.png" alt="Weak Cryptography Exploitation">
      <p>
        An alternative approach is to utilize Frida scripts for this task.
      </p>
    </section>

    <section id="insecure-service" class="mb-5">
      <h2>Insecure Audio Recording Service</h2>

      <p>In the <code>AndroidManifest.xml</code>, you'll notice that
        <code>infosecadventures.allsafe.challenges.RecorderService</code> is
        exported. This means we can directly invoke it to record audio without needing to open the application.
      </p>
      <img src="./images/serv.png" alt="">

      <p>The app has the <code>RECORD_AUDIO</code> permission. If you examine the code, you'll see that when you click
        <code>START AUDIO RECORDER SERVICE</code>, the app initiates the service from
        <code>infosecadventures.allsafe.challenges.RecorderService</code>.
      </p>
      <img src="./images/servstart.png" alt="">

      <p>Inside the <code>RecorderService</code>, you'll find that it configures the Android Media Recorder to capture
        audio for
        only a few seconds. After recording, it saves the audio in MP3 format within the Downloads directory on the SD
        card <code>(/sdcard/Download)</code>.
      </p>
      <img src="./images/servstep.png" alt="">
      <img src="./images/servestore.png" alt="">
      <p>
        To do that just use:
      </p>
      <pre>
        <code>
          adb shell am startservice infosecadventures.allsafe/.challenges.RecorderService
        </code>
      </pre>
      <img src="./images/servexpl.png" alt="Starting Recorder Service">
    </section>
    <section id="object-serialization">
      <h2>Insecure Data Storage and serialization Vulnerability</h2>
      <img src="./images/obj.png" alt="Illustration of the insecure data storage vulnerability">
      <p>
        There appears to be a vulnerability related to insecure data storage, combined with insecure deserialization,
        that can be exploited to gain access to the LOAD USER DATA function.
      </p>
      <img src="./images/obj2.png" alt="User object definition showing properties like username, password, and role">

      <p>
        The code defines a <code>User</code> object, which includes properties for a username, a password, and a default
        role set to
        <code>ROLE_AUTHOR</code>.
      </p>
      <img src="./images/objextranlstorge.png"
        alt="Code snippet showing the serialization process using ObjectOutputStream">

      <p>
        When you enter a username and password in the app and click <code>SAVE USER DATA</code>, it utilizes
        <code>ObjectOutputStream.writeObject</code> to serialize and store a <code>User</code> object in the app's
        External Files Directory,
        located at <code>/sdcard/Android/data/&lt;PackageName&gt;/files</code>.
      </p>

      <p>
        Finally, when you click <code>LOAD USER DATA</code>, it deserializes the <code>User</code> object and verifies
        whether the role is set to <code>ROLE_EDITOR</code>.
      </p>
      <img src="./images/objemethod.png"
        alt="Method showing the deserialization of the User object and role verification">

      <p>
        The app fails to perform any additional checks and does not verify the integrity of the serialized object,
        allowing us to easily modify the stored serialized object and replace it with the original.
      </p>

      <p>
        Typically, I would use <code><a href="https://github.com/redtimmy/SerialTweaker">SerialTweaker</a></code> from
        redtimmy for this task, but given the simplicity of this object, a basic hex editor will suffice.
      </p>

      <img src="./images/objectexploitation.png" alt="Illustration of the exploitation process using a hex editor">
    </section>
    <section>
      <p>
        This challenge involves two Content Providers: one that retrieves notes from a database and another that serves
        as a File Provider. The objective is to evaluate their implementations and determine if it's possible to extract
        information from the database and sensitive files accessed via the File Provider.
      </p>
      <img src="./images/provider.png" alt="">
      <p>Let's begin with the simpler one, <code>infosecadventures.allsafe.challenges.DataProvider</code> Since this
        Content
        Provider is exported, we can directly query it using<code> ADB commands</code>.</p>
      <pre>
          <code>
            adb shell content query --uri "content://infosecadventures.allsafe.dataprovider"
          </code>
        </pre>
      <img src="./images/dataprovider.png" alt="">
      <p>The second provider presents more of a challenge. Since the file provider is not exported, attempting to access
        it directly will result in a <code>java.lang.SecurityException: Permission Denial</code> error.

        Before diving into the details of the vulnerability, it's worth noting that the file provider grants read and
        write access to files listed in a specific resource file located at <code>res/xml/provider_paths.xml</code>
        within the app.
      </p>
      <img src="./images/filepath.png" alt="">
      <p>The <code><files-path></code> tag in the configuration points to the app's file directory, located at
        <code>/data/data/infosecadventures.allsafe/files/</code>. Within this directory, there is a file stored at
        <code>/docs/readme.txt</code>, which is the target file we aim to access through the protected file provider.
      </p>
      <img src="./images/path.png" alt="">
      <P>
        Fortunately, this isnâ€™t the end of the road, as the provider has the <code>android:grantUriPermissions</code>
        flag set to
        <code>true</code>. This flag allows read access to the URI through the intentâ€™s data. Another important point is
        the code
        within <code>infosecadventures.allsafe.ProxyActivity</code>, where it can initiate other activities based on an
        intent that
        is passed to it.
      </P>
      <img src="./images/proxy.png" alt="">
      <p>
        This implies that ProxyActivity can grant us access to the protected content provider. To achieve this, Iâ€™ll
        need to create a malicious application that sets itself as the recipient of an embedded intent and applies the
        <code>Intent.FLAG_GRANT_READ_URI_PERMISSION flag to enable read permissions on the provider. Then, Iâ€™ll have
          <code>Intent.FLAG_GRANT_READ_URI_PERMISSION </code>flag to enable read permissions on the provider. Then, Iâ€™ll have
        ProxyActivity communicate with my app using the intent shown below:
      </p>

    </section>



    <footer class="text-center">
      <p>&copy; 2024 ALsaeed Aziz | All rights reserved.</p>
    </footer>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>